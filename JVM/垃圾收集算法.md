### 垃圾收集算法

1. 标记--清除算法

   >首先使用搜索的方式（从GC Roots开始）搜索与GC Roots相关联的对象，然后标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

   缺点：

   1. 效率问题：
      *  标记和清除的两个过程都不高
   2. 空间问题：
      * 这样会产生连续的空间碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

   

   

   2.复制算法

   > 复制算法是为了解决效率问题，他将可用的内存按容量划分为大小相等的两块，每次只使用一块，当这一块使用完之后，就将存活的对象复制到另外一块上面，然后再把已经使用的内从空间一次清理掉。这样每次就是对整个半区进行内存回收，内存分配时就不用考虑内存碎片化等复杂问题，只需要改变一下指针的位置即可，即（原来的活动区变为空白区，空白区变为活动区）

   缺点

   1. 将内存缩小了原来的一半，未免有些高。

   应用：

   1. 这种复制算法常用来回收新生代，将新生代分为Eden区，两个survior，默认的大小设置为8:1:1，如果另外一块的survior无法存放存活下来的对象，则直接将这些对象放在老年代，而不用非得等到计数到16次（可以设置）再将survior中的对象放到老年代中。
   2. 将此算法应用于年轻代的原因是：
      1. 年轻代的对象的成活率比较低。
      2. 如果成活率比较高的话，应用此算法效率会比较慢，将所有的对象复制到另外一个区域中，并且改变每个对象的指针将会非常的耗时。

   

   3.标记整理算法

   1. 这个算法一开始与标记--清除算法一样，但不一样的是后续的操作不是直接对可回收的对象进行清理，而是让所有存活的对象都向一段移动，然后直接清理掉边界以外的内存。

   

   4.分代收集算法

   把Java堆分为新生代来老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代采用复制算法，因为新生代的存活的对象很少，大都死亡，只需要付出少量存活对象的复制成本就可以完成收集，而老年代由于存活率非常高，常使用标记整理或者标记清除算法。

   

   