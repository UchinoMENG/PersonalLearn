### 运行时数据区域



##### 1. 程序计数器（PC）

> 程序计数器是一块较小的内存空间，可以当做当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过这个计数器的值来选取下一条需要执行的字节码指令，分支，跳转，线程恢复等这些基础功能都需要这个计数器来完成。

1.1程序计数器的例子

首先Java虚拟机中的多线程是通过线程轮流切换并分配处理器执行时间的方式来完成的，在任何一个时刻，一个处理器都只会执行一条线程中的指令。因为，为了能够恢复到正确的位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，这是一块线程私有的内存区域，此区域是一块唯一没有规定任何OutOfMemoryError情况的区域



##### 2.Java虚拟机栈

2.1.Java虚拟机栈也是一块线程私有的内存区域，生命周期与线程相同。虚拟机栈描述的是**Java方法**执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，都对应这一个栈帧在虚拟机栈中从入栈到出栈。

2.2局部变量表存放了编译可知的各种基本数据类型、对象引用和returnAddress类型（指向了一条字节码指令的地址）。

2.3在局部变量表中，其中只有double和long类型的数据会占用两个局部变量空间，其余的类型全都占用一个局部变量空间。局部变量表所需的空间是在编译期间就完成了，当进入一个方法时，这个方法在栈帧中分配多大的局部变量表完全是确定的，在方法运行期间不会改变局部变量表的大小。



##### 3.本地方法栈

3.1·本地方法栈与虚拟机所发挥的作用非常相似，只不过本地方法栈为虚拟机使用到的**Native**方法服务。



##### 4.Java堆

4.1 Java堆是线程共享的区域，也是Java虚拟机所管理的内存中最大的一块。

4.2 堆的唯一目的就是存放对象实例，**几乎所有的对象实例**都在这里分配内存。

4.3 Java堆是垃圾收集器所管理的主要区域，可以分为新生代和老年代。

4.4 Java堆可以处于物理上不连续的内存空间，只要逻辑上连续即可。



##### 5.方法区

5.1 **方法区也是线程共享的内存区域**，它用于存储已被虚拟机加载的**类信息**、**常量**、**静态变量、即时编译器编译后的代码**等数据。

5.2 此区域进行垃圾回收的主要是针对**常量池的回收和对类型的卸载**，这个区域的垃圾回收比较难以令人满意。



###### 6.运行时常量池

常量池：用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载后进入方法区的运行时常量池中存放。

除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。



##### 7. 直接内存

直接内存并不是虚拟机运行时数据区的一部分，但是这部分内存也频繁的使用。

在NIO类中，可以使用零拷贝来使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。



##### 总结：

Java内存区域分为两种类型，线程共享的（方法区，堆），和线程独占的（虚拟机栈，程序计数器，本地方法栈）。

![](https://github.com/UchinoMENG/PersonalLearn/blob/master/image/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png?raw=true)

