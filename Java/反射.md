## 反射

1. 反射具备生成实例的能力，可以拿到类的信息
2. 通过反射可以访问私有类型，需要设置属性visible;
3. 反射的最终目的还是拿到类的实例
4. 反射是编译的时候并不去确定是哪个类被加载了，而是在程序运行的时候才加载、探知、自审。目的是使用在在编译期不知道的类

### 例子

如Java EE框架编写者，并不知道使用者会定义怎样的webServlet,那他是怎么运行起来的，会给使用者一个模板，使用者通过模板编写servlet，而JavaEE则根据模板格式，了解信息，在运行时，动态实例化信息。

这就是反射机制的作用，目的是反向管理类，扫描类信息，通过class.forName()方式然后再取newInstance()实例化，加载到内存。



也就是tomcat是个容器，容器的开发者不知道项目的开发者会写什么类，所以无法用new的方法来给类进行实例化，所以容器开发者也会写出一个类的模板来，当容器运行的时候，用反射的机制按照class.forName()这个方式获取类的信息然后在newInstance()进行实例化然后再运行，容器的开发者会把这个类的模板提供给项目开发者，项目开发者需要根据这个模板的规则来写对应的类，如果没有根据规则来写，也是不可以运行的。



为什么使用反射的原因：没办法通过类的静态加载，拿不到类信息，无法调用。这时采用动态加载，不用检查类是否存在，等到运行的时候检查。

反射功能：获取类信息，生成实例。



对于八大基本类型，他们的句柄信息在哪，他们的值就在哪。引用类型的值全部都在堆里。

堆：主要用来存放数据
栈：用来控制指令的执行顺序（所有和顺序相关的）
和指令无关的放在堆中
方法区：？
计数器：？
本地方法栈：操作系统的方法
线程的开始与结束：以主方法入栈开始，主方法出栈结束
方法按照执行顺序入栈，执行完以后出栈，全部执行完毕（栈空）的过程就是一个线程。
不是所有的句柄在栈里面
凡是在方法内部定义的句柄，全都和顺序有关，肯定在栈里面
基本类型句柄在哪里值就在哪里
引用类型值全部都在堆里面