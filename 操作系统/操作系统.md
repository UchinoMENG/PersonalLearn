# 操作系统

## 操作系统

### 线程和进程的区别

>1. 进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位
>2. 进程之间资源隔离，线程之间资源共享
>3. 一个进程可以有多个线程，线程是进程的一部分，所以线程也被称为轻量级进程。
>4. 每个进程都有独立的代码和数据空间，程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间。每个线程都有自己的程序计数器和线程栈，线程之间的开销较小。
>5. 进程之间有利于资源的管理和保护。

#### 进程的5中状态

1. 创建状态（new）：进程正在被创建，尚未到就绪状态。
2. 就绪状态（ready）:进程处于准备运行状态，获得了除处理器下的所有资源。
3. 运行状态（running）：进程正在处理器上运行（单核cpu任意时刻只有一个进程处于运行状态）。
4. 阻塞状态（waiting）：进程正在等待IO操作，或者其他暂停运行的状态
5. 结束状态（terminated）:进程结束。

#### 进程间的通信方式

<img src="https://i.loli.net/2020/07/29/HeoRdsBJW1mqkUO.png" alt="image-20200729204916025" style="zoom:50%;" />

1. Sockets套接字（C/S结构）
2. 信号（唯一的异步通信机制，可以通过kill命令对其他进程杀死）
3. 共享内存（直接分配一个内存用于共享，但是会导致数据的错乱）
4. 消息队列（消息队列的速度不是最及时的，毕竟每次数据的写入和读取都需要经过用户态和内核态之间的拷贝过程）
5. 信号量（P/V操作进行通信，可用于生产者和消费者）
6. 管道（进程写入的数据都是缓存在内核当中，另一个进程取数据时也是从内核当中）

#### 进程的调度算法

1. 优先级调度
2. 时间片轮转调度算法：每次调度时总是选择就绪队列的队首进程，让其在cpu上运行一个系统预先设置好的时间片。一个时间片没有完成运行的进程，返回到队列末尾重新排队，等待下一次调度。
3. 先到先服务的调度算法

#### 虚拟内存

虚拟内存是计算机系统内存管理的一种技术，它使得应用程序认为它拥有连续可用的内存（一个连续完整的内存空间），而实际上，它通常是被分割成多个物理内存碎片，还有部分暂时存储在外部的磁盘存储器上，在需要的时候进行数据交换。

#### 虚拟存储器

在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序执行过程中，当访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大得多的存储器——虚拟存储器。

#### 页面置换算法

虚拟内存管理很重要的一个概念就是页面置换算法。下面是常用的页面置换算法：地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断。

>缺页中断 就是要访问的页不在内存，需要操作系统将其调入内存后再进行访问。在这个时候，被内存映射的文件实际上成了一个分页交换文件。

当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存中选择一个页面将其移出内存，以便为将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法。

1. FIFO（先进先出页面置换算法）：总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。
2. LRU（最近最久未使用页面置换算法）
3. LFU（最少使用页面置换算法）
4. OPT页面置换算法（最佳页面置换算法）：所换出的页面是最长时间不再被访问，通常可以保证获得最低的缺页率



### 局部性原理

>cpu的工作要高速，我们希望cpu需要的数据更多的就在L1里面，一找就找到。不希望更多的跑到下面内存乃至磁盘里面去找，这样会花更多的时间。所以当cpu用了一个数据，计算机会预见性的存入其他等会cpu可能会用到的数据到L123内存，用到的可能性越大，就能存到越接近寄存器的层次，这也就是缓存的真正意义。
>
>- 时间局部性
>
>  如果一个信息项正在被访问，那么在近期他很可能还会被再次访问
>
>- 空间局部性
>
>  如果一个存储器的位置被引用，那么将来他附近的位置也会被引用



### 什么是死锁？

>在多个并发进程中，如果每个进程持有某种资源而又等待其他进程释放它或他们现在保持着这种状态，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是两个进程或者多个进程无限期的阻塞，相互等待的一种状态。

### 死锁产生的四个条件

- 互斥条件：一个资源只能被一个进程使用
- 请求和保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不变
- 不剥夺条件：进程获得的资源，在未完全使用之前，不能强行剥夺
- 循环等待条件：若干进程之间形成一种头尾交接的环形等待资源关系

### 死锁预防

- 破坏不可剥夺条件：等待期间他占有的资源将被隐式的释放重新加入到系统的资源列表中，可以被其他进程使用
- 破坏“请求和保持条件”：一个方法是：每个进程在开始执行时就申请他所需要的全部资源，另一个方法是每个进程在申请所需要的资源时他本省不占用系统资源。
- 破坏“循环等待”条件：采用资源有序分配其基本思想是将系统中的所有资源顺序编号，在申请资源时必须按照编号的顺序进行。
- 使用银行家算法





### 线程同步的方式有哪些

- 互斥量

  只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个

- 信号量

- 事件：

  >通过通知操作的方式来保持多线程的同步，还可以方便的实现多线程优先级的比较操作



### 虚拟内存

操作系统完成由虚拟内存地址到真实内存地址或者磁盘地址之间的映射工作，这样子给用户提供的虚拟内存的地址空间就可以非常非常大，用户程序中那些很久都用不到的内存空间可以被操作系统弄到磁盘存储，什么时候需要用到了，又从磁盘中加载到真实内存中，这个过程完全是由操作系统自动完成的。



### 内存分段

![image-20200730165126020](https://i.loli.net/2020/07/30/CRyDUe6nc9uPkzO.png)

分段机制下的虚拟地址由两部分组成，段选择子和段内偏移量。

段选择子中有段号，对应着对表中段表的索引，然后再根据段偏移量进行运算。

虚拟地址中的段内偏移量应该位于0到段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。

不足：1. 内存碎片问题 2. 内存交换的效率低

解决办法：使用内存交换



### 内存分页

![image-20200730170024351](https://i.loli.net/2020/07/30/ahQgIloM6DYZOU4.png)

分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小，这样一个连续并且尺寸固定的内存空间，我们叫页。

如果内存空间不够，操作系统会把其他正在运行的进程中的最近没被使用的内存页面给释放掉，也就是暂时写在硬盘上，称为换出。一旦需要的时候，再加载进来，称为换入。

内存地址转换步骤：

- 把虚拟内存地址，切分成页号和偏移量
- 根据页号，从页表里面，查询对应的物理页号
- 直接拿物理页号，加上前面的偏移量，就得到了物理内存地址

缺陷：操作系统是可以运行非常多的进程的，这意味着页面的数量会很大，需要消耗非常多的内存。

### 分页和分段的比较

- 对程序员的透明性：分页透明，但是分段需要程序员显示划分每个段
- 地址空间的维度：分页是一维地址空间，分段是二维的
- 大小是可以改变的：页的大小不可以改变，段的大小可以动态改变
- 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。

### I/O多路复用

I/O多路复用（又称为“事件驱动”），操作系统为你提供了一个功能，当你的某个socket可读或者可写的时候，他可以给你一个通知。这样当配合非阻塞的socket使用时，只有当系统通知我哪个描述符可读了，我才去执行read操作，可以保证每次read都能读到有效数据而不做返回-1的无用功。select/poll/epoll/kqueue之类的系统调用函数来使用，这些函数都可以同时监视多个描述符的读写就绪状态，这样，多个描述符的I/O操作都能在一个线程内并发交替地顺序完成，这就是I/O多路复用

select

- select仅仅返回，但是并不会告诉你那个哪个socket上有数据，于是你得扫描一遍，才可以获取对应的socket
- select只能监视1024个链接
- select不是线程安全的

poll

- 去掉了1024个链接的限制

epoll

- epoll现在是线程安全的
- epoll现在不仅告诉你socket组里面有数据，还会告诉你具体上哪个sock有数据，不用自己去扫描了

### 系统调用

如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。

### 从用户态到内核态的切换

- 系统调用
- 异常：如果当前进程运行在用户态，如果这个时候发生了异常事件，就会触发切换
- 外设中断：当外设完成用户的请求时，就会向cpu发送中断信号



### 用户态和内核态

因为操作系统的资源是有限的，如果访问的资源的操作过多，必然会消耗过多的资源，而且如果不对这些操作加以区分，很可能造成资源访问冲突，为了减少有限资源的访问和使用冲突，就将权限分为内核态和用户态。运行于内核态的进程可以执行的操作和访问的资源都会受到极大的限制，而运行于内核态的进程则可以执行任何操作并且在资源的使用上没有限制。



### 文件描述符

Linux系统中，把一切都看成是文件，当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行I/O操作的系统调用都会通过文件描述符。







